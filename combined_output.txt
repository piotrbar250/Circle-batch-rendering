#pragma once
#include <iostream>
#include <vector>
#include <stdexcept>
#include <glm/glm.hpp>
#include "global.hpp"
using namespace std;
using namespace glm;

class Boid
{
public:
    int index;
    glm::vec2 position;
    glm::vec2 acceleration;
    glm::vec2 velocity;
    glm::vec2 translation;
    
    glm::vec2 initTranslation;

    static vec2 start;
    static float minSpeed;
    static float maxSpeed;
    static float maxForce;

public:
    Boid()
    {
        vec2 realPosition = {randomFloat(100, 700), randomFloat(100, 700)};
        // vec2 tmp = {200.0f, 800.0f};

        initTranslation = realPosition - start;
        position = realPosition;

        acceleration = vec2(0, 0);

        velocity = {randomFloat(-3, 3), randomFloat(-3, 3)};
        if(length(velocity) == 0)
            velocity = vec2(1, 1);
        
        // velocity = vec2(1, 1);

        velocity = setMagnitude(velocity, 1);

        velocity = setMagnitude(velocity, randomFloat(0.5, 1.5));
        // velocity = {0.0f, -3.0f};


        // velocity = glm::normalize(velocity);
    }

    void adjustVelocity()
    {
        if(glm::length(velocity) == 0)
        {
            return;
        }

        if(glm::length(velocity) > maxSpeed)
        {
            velocity = glm::normalize(velocity);
            velocity *= maxSpeed;
            return;
        }

        if(glm::length(velocity) < minSpeed)
        {
            velocity = glm::normalize(velocity);
            velocity *= minSpeed;
            return;
        }
    }

    void antiBorderCollision()
    {
        if(position.x < RADIUS)
            velocity.x *= (-1);

        if(position.x + RADIUS > screenWidth)
            velocity.x *= (-1);

        if(position.y < RADIUS)
            velocity.y *= (-1);

        if(position.y + RADIUS > screenHeight)
            velocity.y *= (-1);
    }  

    void antiBorderCollisionThrough()
    {
        if(position.x < RADIUS)
            position.x = screenWidth - RADIUS;

        if(position.x + RADIUS > screenWidth)
            position.x = RADIUS;

        if(position.y < RADIUS)
            position.y = screenHeight - RADIUS;

        if(position.y + RADIUS > screenHeight)
            position.y = RADIUS;
    }

    vec2 alignmentForce2(const vector<Boid>& neighs)
    {
        vec2 steering = vec2(0,0);
        for(auto& boid : neighs)
            steering += boid.velocity;
    
        if(neighs.size() > 0)
        {
            steering /= neighs.size();
            steering = setMagnitude(steering, maxSpeed);
            steering -= velocity;
            steering = limit(steering, maxForce);
        }
        return steering;
    }

    vec2 alignmentForce(const vector<Boid>& neighs)
    {
        vec2 target = vec2(0,0);
        for(auto& boid : neighs)
            target += boid.velocity;
    
        if(neighs.size() > 0)
            target /= neighs.size();
        else
            target = velocity;

        // cout << target.x << " " << target.y << endl;
        
        return steeringForce(target);
    }

    vec2 steeringForce(vec2 target)
    {
        // cout << index << " " << target.x << " " << target.y << endl << endl;

        vec2 targetOffset = target - velocity;

        vec2 desiredVelocity = {0, 0};
        vec2 steeringForce = {0, 0};

        if(length(targetOffset) > 0)
        {
            desiredVelocity = normalize(targetOffset) * maxSpeed;
            desiredVelocity = setMagnitude(desiredVelocity, maxSpeed);
            vec2 steeringVelocity = desiredVelocity - velocity;
            steeringForce = limit(steeringVelocity, maxForce);
        }
        // cout << steeringForce.x << " " << steeringForce.y << endl;
        // exit(1); 
        return steeringForce;
    }

    vec2 arrivesteeringForce(vec2 target)
    {    
        vec2 targetOffset = target - position;

        float distance = length(targetOffset);

        float rampSpeed = maxSpeed * (distance / SLOWING_DISTANCE);
        float clippedSpeed = std::min(maxSpeed, rampSpeed);

        vec2 desiredVelocity = (clippedSpeed / distance) * targetOffset;

        vec2 steeringVelocity = desiredVelocity - velocity;
        vec2 steeringForce = limit(steeringVelocity, maxForce);

        cout << length(steeringForce) << endl;
        return steeringForce;
    }   

    void applyForces(const vector<Boid>& neighs)
    {
        acceleration *= 0;
        // acceleration += alignmentForce(neighs);
        

        // acceleration = vec2
        acceleration += alignmentForce2(neighs);
        // acceleration += bordersForce();
        // acceleration += steeringForce();
        // acceleration += arrivesteeringForce();
    }
 
    void computeNextFrame(int index, const vector<Boid>& neighs)
    {
        this->index = index;
        applyForces(neighs);

        velocity += acceleration;

        // antiBorderCollision();
        position += velocity;
        
        antiBorderCollisionThrough();

        translation = position - start;

        // cout << velocity.x << " " << velocity.y << " " << position.x << " " << position.y << " " << length(velocity) << " " << length(acceleration) << endl;
    }


    glm::vec2 getTranslation()
    {
        return translation;
    }
    
    vec2 bordersForce()
    {
        float forceValue = BORDER_FORCE;

        if(position.x < RADIUS)
        {
            return vec2(forceValue, 0);
            // acceleration += vec2(forceValue, 0);
        }
        if(position.x + RADIUS > screenWidth)
        {
            return vec2(-forceValue, 0);
            // acceleration += vec2(-forceValue, 0);
        }
        if(position.y < RADIUS)
        {
            return vec2(0, forceValue);
            // acceleration += vec2(0, forceValue);
        }
        if(position.y + RADIUS > screenHeight)
        {
            return vec2(0, -forceValue);;
            // acceleration += vec2(0, forceValue);
        }
        return vec2(0,0);
    }  
};

float Boid::maxSpeed = 4;
float Boid::minSpeed = 0;
float Boid::maxForce = 0.2;
vec2 Boid::start = vec2(START_X, START_Y);

global.hpp
#pragma once
#include <random>
#include <iostream>
#include <stdexcept>
#include <glm/glm.hpp>


const float screenWidth = 1000;
const float screenHeight = 1000;

const float NUMBER_OF_SEGMENTS = 50;
const float RADIUS = 10;
const float START_X = 500;
const float START_Y = 500;

const float BORDER_FORCE = 10;
const float PERCEPTION = 50;
const float SLOWING_DISTANCE = 100;

std::random_device rd;
std::mt19937 eng(rd());

float randomFloat(float l, float r) {
    std::uniform_real_distribution<> distr(l, r);

    return distr(eng);
}

glm::vec2 limit(glm::vec2 v, float l)
{
    if(glm::length(v) > l)
    {
        if(length(v) > 0)
            v = glm::normalize(v) * l;
    }
    return v;
}

glm::vec2 setMagnitude(glm::vec2 v, float l)
{
    if(length(v) == 0)
    {
        // throw std::runtime_error("sm_length(v) == 0");
        return v;
    }
    v = glm::normalize(v) * l;
    return v;
}

take a look a this code:
current alignement works which runs alignmentForce2
i want to use alignmentForce instead and this one doesnt really work
dont tell me how to debug it, find bugs yourself